#!/usr/bin/env node
/* eslint-disable no-console */
'use strict';

let argv = require('yargs').argv,
    esprima = require('esprima'),
    // Default to logging to stdout.
    printer = require(`../printer/${!argv.html ? 'log' : 'html'}`),
    file = argv.file || argv.f,
    results = new Map(),
    visitor;

if (!file) {
    console.log('[ERROR] No file specified');
    return;
}

visitor = {
    collect: (node, results) => {
        let type = node.type;

        if (type === 'ExpressionStatement') {
            let expression = node.expression,
                callee = expression.callee,
                args = expression.arguments;

            if (expression.type === 'CallExpression' && callee.name === 'describe') {
                let node = args[0],
                    value;

                //
                // Node types we're interested in:
                //     --> BinaryExpression
                //     --> ConditionalExpression
                //     --> Literal
                //     --> UnaryExpression
                //

                value = visitor['get' + node.type](node);
                results.set(value, new Map());

                return visitor.visit(args[1].body, visitor.collect, results.get(value));
            }
        }

        return results;
    },

    getBinaryExpression: (() => {
        let getNodeValue = (node) => {
            let value;

            switch (node.type) {
                case 'Identifier':
                    value = node.name;
                    break;

                case 'Literal':
                    value = node.raw;
                    break;

                case 'UnaryExpression':
                    value = visitor.getUnaryExpression(node);
                    break;
            }

            return value;
        };

        return (node) => {
            let nodeLeft = node.left,
                value = [];

            value.push(
                getNodeValue(nodeLeft),
                ' ' + node.operator + ' ',
                getNodeValue(node.right)
            );

            value = value.join(' ');

            while (nodeLeft && nodeLeft.left) {
                return visitor.getBinaryExpression(nodeLeft) + value;
            }

            return value;
        };
    })(),

    getConditionalExpression: (node) => {
        // TODO: Support nested ternaries.
        return [node.test.name, ' ? ', node.consequent.value, ' : ', node.alternate.value].join(' ');
    },

    getLiteral: (node) => {
        return node.value;
    },

    getUnaryExpression: (() => {
        let needsPadding = new Set(['delete', 'instanceof', 'typeof']);

        return (node) => {
            let arg = node.argument,
                // Pad the operator in cases where it's `delete`, `typeof`, etc.
                operator = node.operator;

            if (needsPadding.has(operator)) {
                operator = ' ' + operator + ' ';
            }

            while (arg) {
                return (node.prefix) ?
                    operator + visitor.getUnaryExpression(arg) :
                    visitor.getUnaryExpression(arg) + operator
            }

            return node.name;
        };
    })(),

    visit: function (object, fn, results) {
        results = fn.call(null, object, results);

        for (let n in object) {
            if (object.hasOwnProperty(n)) {
                let obj = object[n];

                if (typeof obj === 'object' && obj !== null) {
                    this.visit(obj, fn, results);
                }
            }
        }

        return results;
    }
};

new Promise((resolve, reject) => {
    console.log('Just a moment while we crunch your suite...');

    return require('fs').readFile(file, 'utf8', (err, fileContents) => {
        if (err) {
            reject('[ERROR] There was a problem processing the file');
        } else {
            resolve(visitor.visit(esprima.parse(fileContents), visitor.collect, results));
        }
    });
})
.then((results) => {
    return printer.init(results);
})
.then(console.log)
.catch(console.log);

