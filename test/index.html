<!DOCTYPE html>
<html>
<head>
<script src="esprima.js" charset="utf-8"></script>
<script>
'use strict';

let getNodeValue = function (node) {
    let value;

    switch (node.type) {
        case 'BinaryExpression':
            value = this.getBinaryExpression(node);
            break;

        case 'ConditionalExpression':
            value = this.getConditionalExpression(node);
            break;

        case 'Identifier':
            value = this.getIdentifier(node);
            break;

        case 'Literal':
            value = this.getLiteral(node);
            break;

        case 'MemberExpression':
            value = this.getMemberExpression(node);
            break;

        case 'ReturnStatement':
            value = this.getReturnStatement(node);
            break;

        case 'UnaryExpression':
            value = this.getUnaryExpression(node);
            break;
    }

    return value;
},
reDescribe = /[f|x]?describe/,
reIt = /[f|x]?it/;

let visitor = Object.setPrototypeOf({
    checkCallExpression: function (node, results, verbose) {
        if (node.type === 'CallExpression') {
            let args = node.arguments,
                name = node.callee.name;

            if (reDescribe.test(name)) {
                let block = {
                    identifier: name,
                    map: new Map()
                };

                results.set(getNodeValue.call(this, args[0]), block);
                return this.visit(args[1].body, block.map, verbose);
            } else if (verbose && reIt.test(name)) {
                results.set(getNodeValue.call(this, args[0]), name);
            }
        }

        return results;
    },

    collect: function (node, results, verbose) {
        let type = node.type;

        if (type === 'ExpressionStatement') {
            return this.checkCallExpression(node.expression, results, verbose);
        } else if (type === 'ReturnStatement') {
            // CoffeeScript transpiles into truly heinous JavaScript. For example,
            // `describe` and `it` blocks were part of return statements, i.e.,
            //      return describe('...', () => {
            //          return it('...', () => {
            //          };
            //      };
            //
            // Because of this, it was necessary to add this if clause.
            return this.checkCallExpression(node.argument, results, verbose);
        }

        return results;
    },

    getBinaryExpression: function (node) {
        let value = [];

        value.push(
            getNodeValue.call(this, node.left),
            node.operator,
            getNodeValue.call(this, node.right)
        );

        return value = value.join(' ');
    },

    getConditionalExpression: function (node) {
        return [
            getNodeValue.call(this, node.test),
            '?',
            getNodeValue.call(this, node.consequent),
            ':',
            getNodeValue.call(this, node.alternate)
        ].join(' ');
    },

    getIdentifier: (node) => {
        return node.name;
    },

    getLiteral: (node) => {
        return node.raw;
    },

    getMemberExpression: function (node) {
        let nestedObj = node.object;

        while (nestedObj) {
            return getNodeValue.call(this, nestedObj) + this.getProperty(node);
        }
    },

    getProperty: function (node) {
        let computed = node.computed;

        return `${(computed ? '[' : '.')}${getNodeValue.call(this, node.property)}${(computed ? ']' : '')}`;
    },

    getUnaryExpression: (() => {
        let needsPadding = new Set(['delete', 'instanceof', 'typeof']);

        return function (node) {
            let arg = node.argument,
                // Pad the operator in cases where it's `delete`, `typeof`, etc.
                operator = node.operator;

            if (needsPadding.has(operator)) {
                operator = ' ' + operator + ' ';
            }

            while (arg) {
                return (node.prefix) ?
                    operator + getNodeValue.call(this, arg) :
                    getNodeValue.call(this, arg) + operator;
            }

            return node.name;
        };
    })(),

    visit: function (object, results, verbose) {
        results = this.collect(object, results, verbose);

        for (let n in object) {
            if (object.hasOwnProperty(n)) {
                let obj = object[n];

                if (typeof obj === 'object' && obj !== null) {
                    this.visit(obj, results, verbose);
                }
            }
        }

        return results;
    }
}, null);

function getSuite(file) {
    return new Promise((resolve, reject) => {
        resolve(file);
    });
}

function makeTree(file, printer, verbose) {
    getSuite(file)
    .then((suite) => {
        let contents = visitTree(suite, verbose);
        return printer.init(contents, verbose);
    })
    .then(console.log)
    .catch(console.log)
}

function visitTree(suite, verbose) {
    console.log('Just a moment while we crunch your suite...');
    return visitor.visit(esprima.parse(suite), new Map(), verbose);
}

/*
let printer = Object.setPrototypeOf({
    makeChildNode: function (name, type) {
        return `<p class="${this.indent < 2 ? 'stripe' : ''}">
            <span class="${type}">
                ${
                    type.indexOf('describe') > -1 ?
                    `(<a href="#">${type}</a>)` :
                    'it -> '
                }
            </span>
            <span>${name}</span>
        </p>`;
    },

    init: function (results, verbose) {
        return new Promise((resolve, reject) => {
            for (let m of results.entries()) {
                let suiteName = m[0],
                    // Trim quotes from the begin and end of the suiteName.
                    newFile = suiteName.replace(/^['"]|['"]$/g, '') + '_suite.html',
                    tpl;

                this.print(m[1].map, [], verbose);
            }
        });
    },

    print: function (map, buf, verbose) {
        this.indent++;

        for (let entry of map.entries()) {
            let entry1 = entry[1],
                map = entry1.map,
                leftPadding = !(this.indent < 2) ? 'padding-left: 50px;' : '';

            if (map || !verbose) {
                let child = [];

                buf.push(`<div style="${leftPadding}">`);
                child.push(this.makeChildNode(entry[0], entry1.identifier));

                // Note that will send an enclosing DIV to wrap all the children for
                // the collapse/expand behavior.
                child.push(this.print(map, ['<div>'], verbose));
                child.push('</div>');

                buf.push(child.join(''), '</div>');
            } else {
                buf.push(`<div style="${leftPadding}">`);
                buf.push(this.makeChildNode(entry[0], entry1));
                buf.push('</div>');
            }
        }

        this.indent--;

        return buf.join('');
    }
}, null);
*/

// We're not worried about putting a counter and a list on the prototype here because each process ends
// directly after the Promises are resolved and there is only ever one 'child' object created at a time.
let BasePrinter = Object.create(null, {
    indent: {
        value: 0,
        writable: true
    },

    print: {
        value: function (map, verbose) {
            this.indent++;

            for (let entry of map.entries()) {
                let entry1 = entry[1],
                    map = entry1.map

                this.captureRow(entry[0], (verbose && !map ? entry1 : entry1.identifier));

                if (map && map.size) {
                    this.print(map, verbose);
                }
            }

            this.indent--;
        }
    },

    rows: {
        value: []
    }
});

let getTabs = (indent) => {
    let tabs = '';

    while (indent) {
        return getTabs(--indent) + '\t';
    }

    return tabs;
};

let printer = Object.setPrototypeOf({
    init: function (results, verbose) {
        // A Promise isn't strictly necessary here.
        return new Promise((resolve) => {
            for (let entry of results.entries()) {
                console.log(entry[0]);
                this.print(entry[1].map, verbose);
            }

            resolve(this.rows.join('\n'));
        });
    },

    captureRow: function (name, type) {
        console.log(`${getTabs(this.indent)}${type} ${name}`);
    }
}, BasePrinter);

document.addEventListener('DOMContentLoaded', () => {
    let xhr = new XMLHttpRequest();

    xhr.onload = () => {
        makeTree(xhr.responseText, printer, /*argv.verbose*/ true);
    };

    xhr.open('GET', 'suite.js');
    xhr.send(null)
});
</script>
</head>

<body>
</body>
</html>

